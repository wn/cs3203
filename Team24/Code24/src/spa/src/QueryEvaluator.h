#ifndef QUERYEVALUATOR_H
#define QUERYEVALUATOR_H

#include "PKB.h"
#include "QEHelper.h"
#include "QPTypes.h"
#include "Query.h"

#include <map>
#include <string>
#include <unordered_map>
#include <vector>

namespace qpbackend {
namespace queryevaluator {
// helper relation type used for evaluation


class SingleQueryEvaluator {
  public:
    explicit SingleQueryEvaluator(const Query& query)
    : query(query), hasClauseFailed(false), hasEvaluationCompleted(false) {
    }

    static SRT_LOOKUP_TABLE srt_table;

    Query query; // the query object generated by the preprocessor
    bool hasClauseFailed; // flag indicates if any clause has failed
    bool hasEvaluationCompleted; // flag indicates evaluation completed

    std::vector<std::string> evaluateQuery(const backend::PKB* pkb); // evaluate the query with the assistance of PKB

  private:
    // table stored candidates of synonyms
    std::unordered_map<std::string, std::vector<std::string>> synonym_candidates;

    // table of pairwise constrain between synonym
    // the key is pair(a, b), a < b
    std::map<std::pair<std::string, std::string>, std::vector<std::pair<std::string, std::string>>> pairConstraints;

    // summarize the result as a string
    std::vector<std::string> produceResult();

    // methods to initialize synonyms and link variables
    void initializeIfSynonym(const backend::PKB* pkb, const std::string& synonymName);
    void initializeCandidate(const backend::PKB* pkb, const std::string& synonymName, EntityType entityType);

    // methods to evaluate generate clause
    bool evaluateSuchThatClause(const backend::PKB* pkb, const RELATIONTUPLE& suchThatClause);
    // TODO
    bool evaluatePatternClause(const backend::PKB* pkb,
                               const std::tuple<std::string, std::string, std::string>& patternClause);

    // evaluate pairwise list relation
    bool evaluateSynonymSynonym(const backend::PKB* pkb,
                                SubRelationType subrelation,
                                const std::string& arg1,
                                const std::string& arg2,
                                bool isPattern,
                                const std::pair<std::string, bool> pattern);

    // evaluate entity and list relation
    bool evaluateEntitySynonym(const backend::PKB* pkb,
                               SubRelationType subRelationType,
                               const std::string& arg1,
                               const std::string& arg2,
                               bool isPattern,
                               const std::pair<std::string, bool> pattern);

    // evaluate entity and entity relation
    bool evaluateEntityEntity(const backend::PKB* pkb,
                              SubRelationType subRelationType,
                              const std::string& arg1,
                              const std::string& arg2);

    // evaluate synonym and Wildcard relation
    bool evaluateSynonymWildcard(const backend::PKB* pkb, SubRelationType subRelationType, const std::string& arg);

    // evaluate entity and Wildcard relation
    bool evaluateEntityWildcard(const backend::PKB* pkb, SubRelationType relationType, const std::string& arg);

    // evaluate synonym and Wildcard relation
    bool evaluateWildcardWildcard(const backend::PKB* pkb, SubRelationType subRelationType);

    // methods called to interact with PKB
    std::vector<std::string>
    inquirePKBForRelation(const backend::PKB* pkb, SubRelationType subRelationType, const std::string& arg);
    std::vector<std::string> inquirePKBForRelationWildcard(const backend::PKB* pkb, SubRelationType subRelationType);
    std::vector<std::string> inquirePKBForPattern(const backend::PKB* pkb,
                                                  SubRelationType subRelationType,
                                                  const std::string& assignee,
                                                  const std::string& assigned,
                                                  bool isSubExpr);

    // helper function
    // check and link synonyms to declared entity type
    bool isSynonym(const backend::PKB* pkb, const std::string& str);
    // check the type of the argument.
    ArgType getArgType(const backend::PKB* pkb, std::string const& arg);

    // error handle
    // TODO
    void handleError(std::string const& msg);
};

// helper functions for vector operations
template <typename T> std::vector<std::string> castToStrVector(const std::vector<T>& v);
template <typename T> bool isFoundInVector(const std::vector<T>& v, T arg);
template <typename T>
std::vector<T> vectorIntersection(const std::vector<T>& lst1, const std::vector<T>& lst2);
template <typename T>
std::vector<T> vectorUnhashableIntersection(const std::vector<T>& lst1, const std::vector<T>& lst2);

class QueryEvaluator {
  public:
    explicit QueryEvaluator(const backend::PKB* pkb) : pkb(pkb) {
    }

    const backend::PKB* pkb;
    std::vector<std::string> evaluateQuery(Query query);
};
} // namespace queryevaluator
} // namespace qpbackend

#endif // QUERYEVALUATOR_H
