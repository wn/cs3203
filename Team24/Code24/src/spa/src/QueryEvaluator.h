#ifndef QUERYEVALUATOR_H
#define QUERYEVALUATOR_H

#include "PKB.h"
#include "QEHelper.h"
#include "Query.h"

#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

namespace qpbackend {
namespace queryevaluator {
// helper relation type used for evaluation
enum SubRelationType {
    PREFOLLOWS, // check a1, Follows(a1, a2)
    POSTFOLLOWS, // check a2, Follows(a1, a2)
    PREFOLLOWST, // check a1, Follows*(a1, a2)
    POSTFOLLOWST // check a2, Follows*(a1, a2)
};

class SingleQueryEvaluator {
  public:
    explicit SingleQueryEvaluator(const Query& query)
    : query(query), clause_failed(false), eval_complete(false) {
    }
    Query query; // the query object generated by the preprocessor
    bool clause_failed; // flag indicates if any clause has failed
    bool eval_complete; // flag indicates evaluation completed

    std::string evaluateQuery(backend::PKB* pkb); // evaluate the query with the assistance of PKB
    ~SingleQueryEvaluator();

  private:
    // table stored candidates of synonyms
    std::unordered_map<std::string, std::vector<std::string>> synonym_candidates;

    // summarize the result as a string
    std::string produceResult();

    // methods to initialize synonyms and link variables
    void initializeSynonym(backend::PKB* pkb, const std::string& syn);
    void initializeCandidate(backend::PKB* pkb, const std::string& syn, EntityType et);

    // methods to evaluate generate clause
    bool evaluateSuchThatClause(backend::PKB* pkb,
                                const std::tuple<RelationType, std::string, std::string>& sc);
    bool evaluatePatternClause(backend::PKB* pkb, const std::tuple<std::string&, std::string, std::string>& pc);

    // evaluate pairwise list relation
    bool evaluateSynonymSynonym(backend::PKB* pkb, SubRelationType srt, const std::string& arg1, const std::string& arg2);

    // evaluate entity and list relation
    bool evaluateEntitySynonym(backend::PKB* pkb, SubRelationType srt, const std::string& arg1, const std::string& arg2);

    // evaluate entity and entity relation
    bool evaluateEntityEntity(backend::PKB* pkb, SubRelationType srt, const std::string& arg1, const std::string& arg2);

    // evaluate synonym and Wildcard relation
    bool evaluateSynonymWildcard(backend::PKB* pkb, SubRelationType srt, const std::string& arg);

    // evaluate entity and Wildcard relation
    bool evaluateEntityWildcard(backend::PKB* pkb, SubRelationType srt, const std::string& arg);

    // evaluate synonym and Wildcard relation
    bool evaluateWildcardWildcard(backend::PKB* pkb, SubRelationType srt);

    // methods called to interact with PKB
    std::vector<std::string>
    inquirePKBForRelation(backend::PKB* pkb, SubRelationType srt, const std::string& arg);
    bool inquirePKBForRelationExist(backend::PKB* pkb, SubRelationType srt, const std::string& arg);

    // helper function
    // methods to check and link synonyms to declared entity type
    bool isSynonym(const std::string& str);

    // error handle
    void handleError();
};


class QueryEvaluator {
  public:
    explicit QueryEvaluator(backend::PKB* pkb) : pkb(pkb) {
    }

    PKB* pkb;
    std::string receiveQuery(Query query);
};

} // namespace queryevaluator
} // namespace qpbackend

#endif // QUERYEVALUATOR_H
