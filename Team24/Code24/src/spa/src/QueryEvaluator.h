#ifndef QUERYEVALUATOR_H
#define QUERYEVALUATOR_H

#include "PKB.h"
#include "QEHelper.h"
#include "QPTypes.h"
#include "Query.h"
#include "ResultTable.h"

#include <map>
#include <string>
#include <unordered_map>
#include <vector>

namespace qpbackend {
namespace queryevaluator {
// helper relation type used for evaluation


class SingleQueryEvaluator {
  public:
    explicit SingleQueryEvaluator(const Query& query)
    : query(query), failed(false), hasEvaluationCompleted(false) {
    }

    static SRT_LOOKUP_TABLE srt_table;
    static ATTR_CONVERT_TABLE attr_convert_table;

    Query query; // the query object generated by the preprocessor
    bool failed; // flag indicates the query is invalid or any clause has failed
    bool hasEvaluationCompleted; // flag indicates evaluation completed

    std::vector<std::string> evaluateQuery(const backend::PKB* pkb); // evaluate the query with the assistance of PKB

  private:
    // table stored candidates of synonyms
    std::unordered_map<std::string, std::vector<std::string>> synonym_candidates;

    // table store tuples
    ResultTable resultTable;

    // summarize the result as a string
    std::vector<std::string> produceResult(const backend::PKB* pkb);

    // methods to initialize synonyms and link variables
    void initializeIfSynonym(const backend::PKB* pkb, const std::string& synonymName);
    void initializeCandidate(const backend::PKB* pkb, const std::string& synonymName, EntityType entityType);

    // methods to evaluate generate clause
    bool evaluateClause(const backend::PKB* pkb, const CLAUSE& clause, ResultTable& groupResultTable);

    // evaluate pairwise list relation
    bool evaluateSynonymSynonym(const backend::PKB* pkb,
                                SubRelationType subrelation,
                                const std::string& arg1,
                                const std::string& arg2,
                                std::string const& patternStr,
                                ResultTable& groupResultTable);

    // evaluate entity and list relation
    bool evaluateEntitySynonym(const backend::PKB* pkb,
                               SubRelationType subRelationType,
                               const std::string& arg1,
                               const std::string& arg2,
                               const std::string& patternStr,
                               ResultTable& groupResultTable);

    // evaluate entity and entity relation
    bool evaluateEntityEntity(const backend::PKB* pkb,
                              SubRelationType subRelationType,
                              const std::string& arg1,
                              const std::string& arg2);

    // evaluate synonym and Wildcard relation
    bool evaluateSynonymWildcard(const backend::PKB* pkb,
                                 SubRelationType subRelationType,
                                 const std::string& arg,
                                 const std::string& patternStr,
                                 ResultTable& groupResultTable);

    // evaluate entity and Wildcard relation
    bool evaluateEntityWildcard(const backend::PKB* pkb, SubRelationType relationType, const std::string& arg);

    // evaluate synonym and Wildcard relation
    bool evaluateWildcardWildcard(const backend::PKB* pkb, SubRelationType subRelationType);

    // methods called to interact with PKB
    std::vector<std::string> inquirePKBForRelationOrPattern(const backend::PKB* pkb,
                                                            SubRelationType subRelationType,
                                                            const std::string& arg,
                                                            const std::string& patternStr);
    std::vector<std::string> inquirePKBForRelationWildcard(const backend::PKB* pkb,
                                                           SubRelationType subRelationType,
                                                           const std::string& patternStr);
    const std::string
    inquirePKBForAttribute(const backend::PKB* pkb, AttrConversion convertType, const std::string& arg);

    // sort and group clauses
    std::vector<std::vector<CLAUSE_LIST>> getClausesSortedAndGrouped(const backend::PKB* pkb);

    // update synonym table with a given result table
    void updateSynonymsWithResultTable(ResultTable& table);

    // helper function
    // check and link synonyms to declared entity type
    bool isSynonym(const std::string& str);

    // validate the clause
    bool validateClause(const CLAUSE& clause);

    // error handle
    // TODO
    void handleError(std::string const& msg);
};

// helper functions for vector operations
template <typename T> std::vector<std::string> castToStrVector(const std::vector<T>& vect);
template <typename T> std::vector<std::string> castToStrVector(const std::unordered_set<T>& s);

template <typename T> bool isFoundInVector(const std::vector<T>& v, T arg);
template <typename T>
std::vector<T> vectorIntersection(const std::vector<T>& lst1, const std::vector<T>& lst2);

class QueryEvaluator {
  public:
    explicit QueryEvaluator(const backend::PKB* pkb) : pkb(pkb) {
    }

    const backend::PKB* pkb;
    std::vector<std::string> evaluateQuery(Query query);
};
} // namespace queryevaluator
} // namespace qpbackend

#endif // QUERYEVALUATOR_H
