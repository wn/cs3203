#ifndef QUERYEVALUATOR_H
#define QUERYEVALUATOR_H

#include "PKB.h"
#include "QEHelper.h"
#include "QPTypes.h"
#include "Query.h"
#include "ResultTable.h"

#include <map>
#include <string>
#include <unordered_map>
#include <vector>

namespace qpbackend {
namespace queryevaluator {
// helper relation type used for evaluation

class SingleQueryEvaluator {
  public:
    explicit SingleQueryEvaluator(const Query& query)
    : query(query), failed(false), hasEvaluationCompleted(false) {
        for (const auto& i : query.returnCandidates) {
            returnSynonyms.insert(i.second);
        }
        for (const auto& i : query.declarationMap) {
            synonymCounters[i.first] = 0;
        }
        for (const auto& clause : query.patternClauses) {
            const ArgType argType1 = std::get<1>(clause).first;
            const ArgType argType2 = std::get<2>(clause).first;
            if (typeIsSynonym(argType1)) {
                synonymCounters[std::get<1>(clause).second]++;
            }
            if (typeIsSynonym(argType2)) {
                synonymCounters[std::get<2>(clause).second]++;
            }
        }
        for (const auto& clause : query.suchThatClauses) {
            const ArgType argType1 = std::get<1>(clause).first;
            const ArgType argType2 = std::get<2>(clause).first;
            if (typeIsSynonym(argType1)) {
                synonymCounters[std::get<1>(clause).second]++;
            }
            if (typeIsSynonym(argType2)) {
                synonymCounters[std::get<2>(clause).second]++;
            }
        }
        for (const auto& clause : query.withClauses) {
            const ArgType argType1 = std::get<0>(std::get<0>(clause));
            const ArgType argType2 = std::get<0>(std::get<1>(clause));
            if (typeIsSynonym(argType1)) {
                synonymCounters[std::get<2>(std::get<0>(clause))]++;
            }
            if (typeIsSynonym(argType2)) {
                synonymCounters[std::get<2>(std::get<1>(clause))]++;
            }
        }
    }

    static SRT_LOOKUP_TABLE srt_table;
    static ATTR_CONVERT_TABLE attr_convert_table;

    Query query; // the query object generated by the preprocessor
    bool failed; // flag indicates the query is invalid or any clause has failed
    bool hasEvaluationCompleted; // flag indicates evaluation completed

    std::vector<std::string> evaluateQuery(const backend::PKB* pkb); // evaluate the query with the assistance of PKB

  private:
    bool typeIsSynonym(ArgType a) {
        return a == STMT_SYNONYM || a == VAR_SYNONYM || a == PROC_SYNONYM || a == CONST_SYNONYM ||
               a == CALL_TO_PROC_SYNONYM || a == READ_TO_VAR_SYNONYM || a == PRINT_TO_VAR_SYNONYM;
    }
    // table stored candidates of synonyms
    std::unordered_map<std::string, std::vector<std::string>> synonym_candidates;
    std::unordered_set<std::string> returnSynonyms;
    std::unordered_map<std::string, int> synonymCounters;

    // table store tuples
    ResultTable resultTable;

    // summarize the result as a string
    std::vector<std::string> produceResult(const backend::PKB* pkb);

    // methods to initialize synonyms and link variables
    void initializeIfSynonym(const backend::PKB* pkb, const std::string& synonymName);
    void initializeCandidate(const backend::PKB* pkb, const std::string& synonymName, EntityType entityType);

    // methods to evaluate generate clause
    bool evaluateClause(const backend::PKB* pkb, const CLAUSE& clause, ResultTable& groupResultTable);

    // evaluate pairwise list relation
    bool evaluateSynonymSynonym(const backend::PKB* pkb,
                                SubRelationType subrelation,
                                ArgType argType1,
                                ArgType argType2,
                                const std::string& arg1,
                                const std::string& arg2,
                                std::string const& patternStr,
                                ResultTable& groupResultTable);

    // evaluate entity and list relation
    bool evaluateEntitySynonym(const backend::PKB* pkb,
                               SubRelationType subRelationType,
                               ArgType synonymArgType,
                               const std::string& arg1,
                               const std::string& arg2,
                               const std::string& patternStr,
                               ResultTable& groupResultTable);

    // evaluate entity and entity relation
    bool evaluateEntityEntity(const backend::PKB* pkb,
                              SubRelationType subRelationType,
                              const std::string& arg1,
                              const std::string& arg2);

    // evaluate synonym and Wildcard relation
    bool evaluateSynonymWildcard(const backend::PKB* pkb,
                                 SubRelationType subRelationType,
                                 const std::string& arg,
                                 const std::string& patternStr,
                                 ResultTable& groupResultTable);

    // evaluate entity and Wildcard relation
    bool evaluateEntityWildcard(const backend::PKB* pkb, SubRelationType relationType, const std::string& arg);

    // evaluate synonym and Wildcard relation
    bool evaluateWildcardWildcard(const backend::PKB* pkb, SubRelationType subRelationType);

    // helper evaluate with condition between synonyms
    // return a list of pair of the synonym value and corresponding attribute
    std::unordered_set<std::vector<std::string>, StringVectorHash>
    evaluateSynonymAttrForWith(const backend::PKB* pkb, SubRelationType srt, ArgType argType, const std::string& arg);

    // methods called to interact with PKB
    std::vector<std::string> inquirePKBForRelationOrPattern(const backend::PKB* pkb,
                                                            SubRelationType subRelationType,
                                                            const std::string& arg,
                                                            const std::string& patternStr);
    std::vector<std::string> inquirePKBForRelationWildcard(const backend::PKB* pkb,
                                                           SubRelationType subRelationType,
                                                           const std::string& patternStr);
    const std::string
    inquirePKBForAttribute(const backend::PKB* pkb, ArgType convertType, const std::string& arg);

    // sort and group clauses
    std::vector<std::vector<CLAUSE_LIST>> getClausesSortedAndGrouped(const backend::PKB* pkb);

    // update synonym table with a given result table
    void updateSynonymsWithResultTable(ResultTable& table, bool prune = false);

    // helper function
    // check and link synonyms to declared entity type
    bool isSynonym(const std::string& str);

    // relation / argument conversion helper
    SubRelationType getSubRelationType(ClauseType clauseType, ArgType argType1, ArgType argType2);
    ArgType getAttrArgType(ReturnType returnType, const std::string& synonym);
    ARG getWithArgType(const ATTR_ARG& attrArg);

    // validate the clause
    bool validateClause(const CLAUSE& clause);

    // error handle
    // TODO
    void handleError(std::string const& msg);
};

// helper functions for vector operations
template <typename T> std::vector<std::string> castToStrVector(const std::vector<T>& vect);
template <typename T> std::vector<std::string> castToStrVector(const std::unordered_set<T>& s);

template <typename T> bool isFoundInVector(const std::vector<T>& v, T arg);
template <typename T>
std::vector<T> vectorIntersection(const std::vector<T>& lst1, const std::vector<T>& lst2);

class QueryEvaluator {
  public:
    explicit QueryEvaluator(const backend::PKB* pkb) : pkb(pkb) {
    }

    const backend::PKB* pkb;
    std::vector<std::string> evaluateQuery(Query query);
};
} // namespace queryevaluator
} // namespace qpbackend

#endif // QUERYEVALUATOR_H
